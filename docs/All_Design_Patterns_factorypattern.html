<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Factory Pattern - Design Patterns</title>
  <link rel="stylesheet" href="tools/index_style.css">
  <link rel="stylesheet" href="tools/patterns_responsive.css">
  <link rel="stylesheet" href="tools/pattern_page.css">
  <link rel="stylesheet" href="tools/pattern_layout.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
</head>
<body style="background: #f7fafc;">
  <div style="max-width: 1200px; margin: 0 auto; padding: 1.5rem;">
    <a href="All_Design_Patterns_index.html" class="back-button">‚Üê Back to Patterns</a>
    
    <div class="pattern-header">
      <div class="breadcrumb">Design Patterns</div>
      <h1>Factory Pattern</h1>
    </div>

    <div class="pattern-container">
      <aside class="pattern-toc">
        <h4>Contents</h4>
        <ul id="toc-list"></ul>
      </aside>
      <div class="pattern-main">
        <div class="uml-section">
    <h2>Class Diagram</h2>
    <div class="mermaid">classDiagram
    class ShapeInterface {
        draw() void
    }
    
    class Circle {
        draw() void
    }
    
    class Rectangle {
        draw() void
    }
    
    class ShapeFactory {
        getShape(String) ShapeInterface
    }
    
    class Client {
        main() void
    }
    
    ShapeInterface <|.. Circle
    ShapeInterface <|.. Rectangle
    ShapeFactory --> ShapeInterface
    Client --> ShapeFactory</div>
    <div class="uml-caption">UML Class Diagram for Factory Pattern</div>
  </div>
  
        <article id="content" class="markdown-body"></article>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script id="md-data" type="application/json">"# Factory Pattern \u2014 Interview Reference\n\n## Intent\nProvide a method to create objects without exposing the instantiation logic, returning interface types to callers.\n\n## Problem Statement\nClient code directly depends on concrete classes, creating tight coupling. When new shape types are added, client code must change, violating Open/Closed Principle.\n\n## Why Simple Code Fails\nScattering `new` constructors throughout the code and using `if-else` logic for type selection leads to:\n- Tight coupling to concrete classes (Circle, Rectangle)\n- Hard to add new shapes without modifying client code\n- Creation logic scattered across multiple files\n- Difficult to test (can't mock object creation)\n\n## Solution Overview\nIntroduce a ShapeFactory that encapsulates shape creation. Client code depends on the factory and the Shape interface, not on concrete implementations.\n\n## Participants / Roles\n- ShapeInterface (abstract product interface)\n- Circle, Rectangle (concrete products)\n- ShapeFactory (creator/factory)\n- Client (uses factory to get shapes)\n\n## Runtime Execution Flow\n1. Client calls `ShapeFactory.getShape(shapeType)`\n2. Factory checks the shape type string\n3. Factory instantiates appropriate concrete Shape\n4. Factory returns Shape interface to client\n5. Client calls methods on Shape interface (draw())\n\n## Minimal Java Example\n\n### Without Pattern\n\n```java\n// WITHOUT Factory - client directly instantiates shapes\npublic class ClientWithoutFactory {\n  public static void main(String args[]) {\n    // Tightly coupled to concrete classes!\n    if (userInput.equals(\"circle\")) {\n      Shape s = new Circle();  // Depends on Circle\n      s.draw();\n    } else if (userInput.equals(\"rectangle\")) {\n      Shape s = new Rectangle();  // Depends on Rectangle\n      s.draw();\n    }\n  }\n}\n```\n\n### With Pattern\n\n```java\n// Product interface\npublic interface ShapeInterface {\n  public void draw();\n}\n\n// Concrete products\npublic class Circle implements ShapeInterface {\n  @Override\n  public void draw() {\n    System.out.println(\"Drawing Circle\");\n  }\n}\n\npublic class Rectangle implements ShapeInterface {\n  @Override\n  public void draw() {\n    System.out.println(\"Drawing Rectangle\");\n  }\n}\n\n// Factory\npublic class ShapeFactory {\n  public ShapeInterface getShape(String shapeType) {\n    if (shapeType == null) return null;\n    \n    if (shapeType.equals(\"circle\")) {\n      return new Circle();\n    } else if (shapeType.equals(\"rectangle\")) {\n      return new Rectangle();\n    }\n    return null;\n  }\n}\n\n// Client\npublic class Client {\n  public static void main(String args[]) {\n    ShapeFactory shapeFactory = new ShapeFactory();\n    \n    ShapeInterface shape1 = shapeFactory.getShape(\"circle\");\n    shape1.draw();\n    \n    ShapeInterface shape2 = shapeFactory.getShape(\"rectangle\");\n    shape2.draw();\n  }\n}\n\n// Output:\n// Drawing Circle\n// Drawing Rectangle\n```\n\n## Advantages\n- Isolates client from concrete class dependencies\n- Centralizes object creation logic in one place\n- Easy to add new shape types\n- Follows Open/Closed Principle\n- Improves code testability\n\n## Disadvantages\n- Adds extra layer of abstraction\n- Factory class can grow large with many product types\n- If-else logic can become hard to maintain\n- May be overkill for few object types\n\n## When NOT to Use\nWhen you have only one product type or when object creation is trivial.\n\n## Common Mistakes\n- Putting business logic in factories\n- Returning concrete types instead of interfaces\n- Not making factory creation conditional\n\n## Framework / Library Usage\n- **java.util.Calendar**: `Calendar.getInstance()` returns specific calendar implementations\n- **java.nio.file.Files**: `Files.newInputStream()` creates file input streams\n- **Logging frameworks**: `LoggerFactory.getLogger()` creates logger instances\n- **Database drivers**: `DriverManager.getConnection()` creates connections\n\n## System Design Use Cases\n- File format handlers (PDF, DOCX, PNG creation)\n- Document parsers (JSON, XML, CSV parsing)\n- UI component creation (Button, TextField, Dialog creation)\n- Payment gateway adapters (PayPal, Stripe, Square)\n\n## Interview One-Liner\nFactory Pattern defines an interface for creating objects and lets subclasses or factory methods decide which concrete class to instantiate, centralizing creation logic and reducing client coupling.\n\n## Common Interview Questions\n\n### Q1: What's the difference between Factory Method and Factory Pattern?\n\n**Answer:**\nThese terms are often used interchangeably, but technically:\n\n| Aspect | Factory Method | Factory Pattern |\n|--------|---|---|\n| **Definition** | A method that creates objects | A design pattern using factory methods |\n| **Scope** | Method-level | Class/object-level |\n| **Usage** | Single factory method | Entire pattern with factory class |\n| **Example** | `ShapeFactory.getShape()` | Entire ShapeFactory class |\n\nThe Factory Pattern typically refers to using a dedicated factory class or method to handle object creation.\n\n---\n\n### Q2: How would you add a new shape (Triangle) to the existing system?\n\n**Answer:**\nWith Factory Pattern, adding a new shape is simple - just implement the interface and update the factory:\n\n```java\n// Step 1: Create new concrete product\npublic class Triangle implements ShapeInterface {\n  @Override\n  public void draw() {\n    System.out.println(\"Drawing Triangle\");\n  }\n}\n\n// Step 2: Update factory to handle new type\npublic class ShapeFactory {\n  public ShapeInterface getShape(String shapeType) {\n    if (shapeType == null) return null;\n    \n    if (shapeType.equals(\"circle\")) {\n      return new Circle();\n    } else if (shapeType.equals(\"rectangle\")) {\n      return new Rectangle();\n    } else if (shapeType.equals(\"triangle\")) {  // NEW!\n      return new Triangle();\n    }\n    return null;\n  }\n}\n\n// Step 3: Client code works without ANY changes!\nShapeFactory factory = new ShapeFactory();\nShapeInterface s = factory.getShape(\"triangle\");\ns.draw();  // Output: Drawing Triangle\n```\n\n**Key Point:** Client code doesn't need to change!\n\n---\n\n### Q3: What problems arise if you don't use Factory Pattern?\n\n**Answer:**\nWithout the factory, you'd scatter shape creation throughout your code:\n\n```java\n// WITHOUT Factory - PROBLEMS!\npublic class ReportGenerator {\n  public void generateReport(String shapeType) {\n    // Creation logic scattered here\n    if (shapeType.equals(\"circle\")) {\n      Shape s = new Circle();\n    } else if (shapeType.equals(\"rectangle\")) {\n      Shape s = new Rectangle();\n    }\n    s.draw();\n  }\n}\n\npublic class GraphicsEditor {\n  public void createShape(String shapeType) {\n    // SAME logic repeated here!\n    if (shapeType.equals(\"circle\")) {\n      Shape s = new Circle();\n    } else if (shapeType.equals(\"rectangle\")) {\n      Shape s = new Rectangle();\n    }\n    s.draw();\n  }\n}\n```\n\n**Problems:**\n1. **Code duplication** - Same if/else in multiple classes\n2. **Hard to maintain** - Adding new shapes means changing multiple places\n3. **Tight coupling** - All classes depend on concrete classes\n4. **Single Responsibility violated** - Classes handle both creation and usage\n\n**WITH Factory - CLEAN!**\n```java\npublic class ReportGenerator {\n  private ShapeFactory factory = new ShapeFactory();\n  \n  public void generateReport(String shapeType) {\n    ShapeInterface s = factory.getShape(shapeType);\n    s.draw();\n  }\n}\n```\n\n---\n\n### Q4: How does Factory Pattern support the Open/Closed Principle?\n\n**Answer:**\nFactory Pattern is **OPEN for extension** but **CLOSED for modification**:\n\n```java\n// Better approach: use a Map for extensibility\npublic class ConfigurableShapeFactory {\n  private static Map<String, ShapeInterface> shapeCache = new HashMap<>();\n  \n  static {\n    shapeCache.put(\"circle\", new Circle());\n    shapeCache.put(\"rectangle\", new Rectangle());\n  }\n  \n  public ShapeInterface getShape(String type) {\n    return shapeCache.get(type.toLowerCase());\n  }\n  \n  // OPEN: Add new shape via registration\n  public static void registerShape(String name, ShapeInterface shape) {\n    shapeCache.put(name, shape);\n  }\n}\n\n// Extending without modifying factory:\nConfigurableShapeFactory.registerShape(\"triangle\", new Triangle());\nShapeInterface triangle = factory.getShape(\"triangle\");  // Now works!\n```\n\n---\n\n### Q5: Can Factory Pattern be combined with other patterns?\n\n**Answer:**\nYes! Factory Pattern works well with other patterns:\n\n**1. Factory + Singleton:**\n```java\npublic class SingletonShapeFactory {\n  private static SingletonShapeFactory instance;\n  \n  private SingletonShapeFactory() {}\n  \n  public static synchronized SingletonShapeFactory getInstance() {\n    if (instance == null) {\n      instance = new SingletonShapeFactory();\n    }\n    return instance;\n  }\n  \n  public ShapeInterface getShape(String type) {\n    // ... factory logic\n  }\n}\n\nShapeInterface shape = SingletonShapeFactory.getInstance().getShape(\"circle\");\n```\n\n**2. Factory + Strategy:**\n```java\npublic interface ShapeCreationStrategy {\n  ShapeInterface createShape();\n}\n\npublic class StrategyBasedShapeFactory {\n  private Map<String, ShapeCreationStrategy> strategies = new HashMap<>();\n  \n  public ShapeInterface getShape(String type) {\n    ShapeCreationStrategy strategy = strategies.get(type);\n    return strategy.createShape();\n  }\n}\n```\n\n---\n\n### Q6: How to avoid switch/if-else in factories?\n\n**Answer:**\nThere are several approaches to eliminate if-else chains:\n\n**Approach 1: Map-based Registry (Recommended)**\n```java\npublic class RegistryShapeFactory {\n  private static Map<String, Class<?>> registry = new HashMap<>();\n  \n  static {\n    registry.put(\"circle\", Circle.class);\n    registry.put(\"rectangle\", Rectangle.class);\n    registry.put(\"triangle\", Triangle.class);\n  }\n  \n  public ShapeInterface getShape(String type) {\n    try {\n      Class<?> clazz = registry.get(type.toLowerCase());\n      return (ShapeInterface) clazz.getDeclaredConstructor().newInstance();\n    } catch (Exception e) {\n      throw new IllegalArgumentException(\"Unknown shape: \" + type);\n    }\n  }\n  \n  public static void registerShape(String name, Class<?> shapeClass) {\n    registry.put(name, shapeClass);\n  }\n}\n\nShapeFactory factory = new RegistryShapeFactory();\nShapeInterface shape = factory.getShape(\"circle\");\nRegistryShapeFactory.registerShape(\"polygon\", Polygon.class);\n```\n\n**Approach 2: Enum-based Factory**\n```java\npublic enum ShapeType {\n  CIRCLE(Circle::new),\n  RECTANGLE(Rectangle::new),\n  TRIANGLE(Triangle::new);\n  \n  private final Supplier<ShapeInterface> supplier;\n  \n  ShapeType(Supplier<ShapeInterface> supplier) {\n    this.supplier = supplier;\n  }\n  \n  public ShapeInterface create() {\n    return supplier.get();\n  }\n}\n\nShapeInterface circle = ShapeType.CIRCLE.create();  // Type-safe!\n```\n\n---\n\n### Q7: When choose Factory vs Builder?\n\n**Answer:**\nFactory and Builder solve different problems:\n\n**Use Factory Pattern when:**\n- Creating **simple objects** with few variations\n- Need to **hide concrete class** details from client\n- Creating objects **based on a type/condition**\n- Object creation is **straightforward**\n\n**Use Builder Pattern when:**\n- Creating **complex objects** with many properties\n- Object has **many optional parameters**\n- Need to create **different representations** of same object\n- Want to avoid **telescoping constructors**\n- Need **immutable objects** with validation\n\n**Comparison:**\n\n| Aspect | Factory | Builder |\n|--------|---------|---------|\n| **Object Complexity** | Simple | Complex (many properties) |\n| **Number of Parameters** | Few | Many (with optionals) |\n| **Constructor Overloads** | 1-2 | Avoided |\n| **Validation** | Optional | At build() time |\n| **Immutability** | Not guaranteed | Can be guaranteed |\n| **Creation Process** | One-shot | Step-by-step |\n\n**Example:**\n```java\n// FACTORY: Simple type selection\npublic class DatabaseFactory {\n  public Database createDatabase(String dbType) {\n    switch(dbType) {\n      case \"mysql\": return new MySQLDatabase();\n      case \"postgres\": return new PostgresDatabase();\n      case \"mongodb\": return new MongoDBDatabase();\n      default: throw new IllegalArgumentException();\n    }\n  }\n}\n\n// BUILDER: Complex object construction\nDatabaseConfig config = new DatabaseConfigBuilder()\n  .host(\"db.example.com\")\n  .port(5432)\n  .username(\"admin\")\n  .password(\"secret\")\n  .poolSize(20)\n  .build();\n```\n\n**Key Insight:**\n- **Factory** = \"What type should I create?\"\n- **Builder** = \"How should I construct this complex object?\"\n\n"</script>
  <script src="tools/pattern_renderer.js"></script>
</body>
</html>