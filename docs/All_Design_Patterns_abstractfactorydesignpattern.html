<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Abstract Factory Pattern - Design Patterns</title>
  <link rel="stylesheet" href="tools/index_style.css">
  <link rel="stylesheet" href="tools/patterns_responsive.css">
  <link rel="stylesheet" href="tools/pattern_page.css">
  <link rel="stylesheet" href="tools/pattern_layout.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
</head>
<body style="background: #f7fafc;">
  <div style="max-width: 1200px; margin: 0 auto; padding: 1.5rem;">
    <a href="All_Design_Patterns_index.html" class="back-button">‚Üê Back to Patterns</a>
    
    <div class="pattern-header">
      <div class="breadcrumb">Design Patterns</div>
      <h1>Abstract Factory Pattern</h1>
    </div>

    <div class="pattern-container">
      <aside class="pattern-toc">
        <h4>Contents</h4>
        <ul id="toc-list"></ul>
      </aside>
      <div class="pattern-main">
        <div class="uml-section">
    <h2>Class Diagram</h2>
    <div class="mermaid">classDiagram
    class UIFactory {
        <<interface>>
        +createButton() Button
        +createCheckbox() Checkbox
    }

    class WindowsUIFactory {
        +createButton() Button
        +createCheckbox() Checkbox
    }

    class MacUIFactory {
        +createButton() Button
        +createCheckbox() Checkbox
    }

    class Button {
        <<interface>>
        +click()
        +render()
    }

    class WindowsButton {
        +click()
        +render()
    }

    class MacButton {
        +click()
        +render()
    }

    class Checkbox {
        <<interface>>
        +toggle()
        +render()
    }

    class WindowsCheckbox {
        +toggle()
        +render()
    }

    class MacCheckbox {
        +toggle()
        +render()
    }

    class Application {
        -factory: UIFactory
        +render()
    }

    UIFactory <|.. WindowsUIFactory
    UIFactory <|.. MacUIFactory
    
    Button <|.. WindowsButton
    Button <|.. MacButton
    Checkbox <|.. WindowsCheckbox
    Checkbox <|.. MacCheckbox
    
    WindowsUIFactory --> WindowsButton: creates
    WindowsUIFactory --> WindowsCheckbox: creates
    MacUIFactory --> MacButton: creates
    MacUIFactory --> MacCheckbox: creates
    
    Application --> UIFactory: uses
    Application --> Button: uses
    Application --> Checkbox: uses</div>
    <div class="uml-caption">UML Class Diagram for Abstract Factory Pattern</div>
  </div>
  
        <article id="content" class="markdown-body"></article>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script id="md-data" type="application/json">"# Abstract Factory Pattern \u2014 Interview Reference\n\n## Intent\nProvide an interface for creating families of related or dependent objects without specifying their concrete classes.\n\n## Problem Statement\nApplications need to work with multiple families of related objects (e.g., UI components for Windows vs macOS, database drivers for SQL vs NoSQL). Hardcoding concrete classes creates tight coupling and makes it difficult to switch between families or add new ones.\n\n## Why Simple Code Fails\nUsing conditional logic (if/else) scattered throughout the code to decide which concrete class to instantiate leads to:\n- Tight coupling between client code and concrete classes\n- Difficult to add new product families without modifying existing code\n- Hard to maintain consistency within a family of objects\n- Violates Open/Closed Principle\n\n## Solution Overview\nDefine an abstract factory interface that declares methods for creating abstract products. Implement concrete factories for each product family. This allows clients to work with product families through abstract interfaces without knowing concrete classes.\n\n## Participants / Roles\n- AbstractFactory (declares factory methods)\n- ConcreteFactory (implements factory methods for a family)\n- AbstractProduct (declares product interface)\n- ConcreteProduct (implements specific product)\n\n## Runtime Execution Flow\n1. Client requests a factory for a specific family\n2. Client uses factory methods to create products\n3. Factory returns concrete products as abstract types\n4. Client works with products through abstract interfaces\n\n## Minimal Java Example\n## Without Pattern\n\n```java\n// Tightly coupled - hard to switch UI families\nif (osType.equals(\"WINDOWS\")) {\n  Button btn = new WindowsButton();\n  Checkbox cb = new WindowsCheckbox();\n} else if (osType.equals(\"MAC\")) {\n  Button btn = new MacButton();\n  Checkbox cb = new MacCheckbox();\n}\n```\n\n## With Pattern\n\n```java\n// Abstract factory\npublic abstract class EmployeeAbstractFactory {\n  public abstract Employee createEmployee();\n}\n\n// Concrete factories for different developer types\npublic class WebDeveloperFactory extends EmployeeAbstractFactory {\n  @Override\n  public Employee createEmployee() {\n    return new WebDeveloper();\n  }\n}\n\npublic class AndroidDeveloperFactory extends EmployeeAbstractFactory {\n  @Override\n  public Employee createEmployee() {\n    return new AndroidDeveloper();\n  }\n}\n\n// Product interface\npublic interface Employee {\n  public int getSalary();\n  public String name();\n}\n\n// Concrete products\npublic class WebDeveloper implements Employee {\n  @Override\n  public int getSalary() {\n    return 12000;\n  }\n  \n  @Override\n  public String name() {\n    return \"Web Developer\";\n  }\n}\n\npublic class AndroidDeveloper implements Employee {\n  @Override\n  public int getSalary() {\n    return 15000;\n  }\n  \n  @Override\n  public String name() {\n    return \"Android Developer\";\n  }\n}\n\n// Factory method to create employees\npublic class EmployeeFactory {\n  public static Employee getEmployee(EmployeeAbstractFactory factory) {\n    return factory.createEmployee();\n  }\n}\n\n// Client code\npublic class Client {\n  public static void main(String args[]) {\n    // Create Web Developer using factory\n    Employee e1 = EmployeeFactory.getEmployee(new WebDeveloperFactory());\n    System.out.println(\"Employee: \" + e1.name() + \", Salary: \" + e1.getSalary());\n    \n    // Create Android Developer using factory\n    Employee e2 = EmployeeFactory.getEmployee(new AndroidDeveloperFactory());\n    System.out.println(\"Employee: \" + e2.name() + \", Salary: \" + e2.getSalary());\n  }\n}\n\n// Output:\n// Employee: Web Developer, Salary: 12000\n// Employee: Android Developer, Salary: 15000\n```\n\n## Advantages\n- Isolates client from concrete classes (Dependency Inversion)\n- Ensures products within a family work together consistently\n- Makes it easy to add new product families\n- Centralizes object creation logic\n- Follows Open/Closed Principle (new families without modifying existing code)\n- Improves code testability (use mock factories)\n\n## Disadvantages\n- Adds complexity with many abstract classes and interfaces\n- Can be overkill for simple applications\n- Makes class hierarchy deeper and harder to navigate\n- Adding new product types requires modifying all concrete factories\n\n## When NOT to Use\n- When you only have one family of products\n- When products don't need to work together as families\n- When application is unlikely to support multiple product families\n- Simple Factory or Factory Method patterns may be sufficient\n\n## Common Mistakes\n- Creating too many abstract layers upfront\n- Confusing Abstract Factory with Factory Method\n- Not ensuring consistency within product families\n- Overusing the pattern for simple object creation\n\n## Framework / Library Usage\n- **Swing/AWT**: Different UI factories for different look-and-feels\n- **JDBC**: Database connection factories for different databases\n- **Spring**: BeanFactory and ApplicationContext as abstract factories\n- **XML Parsers**: Different parser factories (DOM, SAX, StAX)\n\n## System Design Use Cases\n- Cross-platform UI applications (Windows/Mac/Linux)\n- Database abstraction layers (MySQL, PostgreSQL, MongoDB)\n- Cloud provider SDKs (AWS, Azure, GCP)\n- Document generation (PDF, HTML, Excel)\n- Game development (different rendering engines)\n\n## Interview One-Liner\nAbstract Factory provides an interface for creating families of related objects without coupling clients to concrete classes, ensuring products within a family work together consistently.\n\n## Common Interview Questions\n\n### Q1: What's the difference between Abstract Factory and Factory Method?\n\n**Answer:**\n| Aspect | Factory Method | Abstract Factory |\n|--------|---|---|\n| **Purpose** | Creates single product type | Creates families of related products |\n| **Hierarchy** | Single class hierarchy | Multiple related hierarchies |\n| **Usage** | `Creator.factoryMethod()` | `Factory.createProductA()` + `Factory.createProductB()` |\n| **Example** | `ShapeFactory.getShape()` returns one Shape | `UIFactory` returns Button AND Checkbox together |\n| **Coupling** | Reduces coupling to one product | Reduces coupling to related product families |\n\n**Example Comparison:**\n```java\n// Factory Method - creates ONE product type\ninterface ShapeFactory {\n  Shape createShape();  // only one method\n}\n\n// Abstract Factory - creates FAMILY of products\ninterface UIFactory {\n  Button createButton();      // multiple methods\n  Checkbox createCheckbox();\n  TextField createTextField();\n}\n```\n\n---\n\n### Q2: How would you handle adding a new product type to an existing family?\n\n**Answer:**\nYou must modify ALL concrete factories in the family. For example, if you want to add `IOSDeveloper` to the Employee factory family:\n\n```java\n// Original abstract factory\npublic abstract class EmployeeAbstractFactory {\n  public abstract Employee createEmployee();\n}\n\n// After adding IOSDeveloper: create new factory\npublic class IOSDeveloperFactory extends EmployeeAbstractFactory {\n  @Override\n  public Employee createEmployee() {\n    return new IOSDeveloper();  // NEW!\n  }\n}\n\n// Concrete product\npublic class IOSDeveloper implements Employee {\n  @Override\n  public int getSalary() {\n    return 16000;\n  }\n  \n  @Override\n  public String name() {\n    return \"iOS Developer\";\n  }\n}\n\n// Usage in client\npublic class Client {\n  public static void main(String args[]) {\n    // Existing developers\n    Employee e1 = EmployeeFactory.getEmployee(new WebDeveloperFactory());\n    System.out.println(e1.name() + \": $\" + e1.getSalary());\n    \n    Employee e2 = EmployeeFactory.getEmployee(new AndroidDeveloperFactory());\n    System.out.println(e2.name() + \": $\" + e2.getSalary());\n    \n    // NEW iOS Developer - seamlessly added!\n    Employee e3 = EmployeeFactory.getEmployee(new IOSDeveloperFactory());\n    System.out.println(e3.name() + \": $\" + e3.getSalary());\n  }\n}\n\n// Output:\n// Web Developer: $12000\n// Android Developer: $15000\n// iOS Developer: $16000\n```\n\n**Key Point:** Notice you DON'T need to modify EmployeeAbstractFactory, Employee, WebDeveloperFactory, or AndroidDeveloperFactory. You only add NEW concrete factories. This follows Open/Closed Principle!\n\n---\n\n### Q3: Can Abstract Factory be used with Singleton? How?\n\n**Answer:**\nYes! You can create a singleton factory provider that returns the appropriate factory:\n\n```java\n// Singleton Factory Provider\npublic class EmployeeFactoryProvider {\n  private static EmployeeFactoryProvider instance;\n  private Map<String, EmployeeAbstractFactory> factories;\n  \n  private EmployeeFactoryProvider() {\n    factories = new HashMap<>();\n    factories.put(\"WEB\", new WebDeveloperFactory());\n    factories.put(\"ANDROID\", new AndroidDeveloperFactory());\n    factories.put(\"IOS\", new IOSDeveloperFactory());\n  }\n  \n  public static EmployeeFactoryProvider getInstance() {\n    if (instance == null) {\n      instance = new EmployeeFactoryProvider();\n    }\n    return instance;\n  }\n  \n  public EmployeeAbstractFactory getFactory(String type) {\n    return factories.get(type.toUpperCase());\n  }\n}\n\n// Usage - only ONE factory provider instance in entire app\npublic class Client {\n  public static void main(String args[]) {\n    EmployeeFactoryProvider provider = EmployeeFactoryProvider.getInstance();\n    \n    // Get factories from singleton provider\n    EmployeeAbstractFactory webFactory = provider.getFactory(\"WEB\");\n    Employee e1 = EmployeeFactory.getEmployee(webFactory);\n    System.out.println(e1.name() + \": $\" + e1.getSalary());\n    \n    EmployeeAbstractFactory androidFactory = provider.getFactory(\"ANDROID\");\n    Employee e2 = EmployeeFactory.getEmployee(androidFactory);\n    System.out.println(e2.name() + \": $\" + e2.getSalary());\n  }\n}\n\n// Output:\n// Web Developer: $12000\n// Android Developer: $15000\n```\n\n**Benefits:**\n- Single factory provider instance across application\n- All factories managed in one place\n- Easy to add new factories (just add to map)\n- Thread-safe factory access (with synchronization)\n\n---\n\n### Q4: What problems does Abstract Factory solve that simple conditionals don't?\n\n**Answer:**\nWithout Abstract Factory, you scatter creation logic everywhere with conditionals:\n\n```java\n// WITHOUT Abstract Factory - BAD!\npublic class EmployeeService {\n  public void hireEmployee(String type) {\n    Employee emp;\n    \n    if (type.equals(\"WEB\")) {  // scattered logic\n      emp = new WebDeveloper();\n    } else if (type.equals(\"ANDROID\")) {  // scattered logic\n      emp = new AndroidDeveloper();\n    } else if (type.equals(\"IOS\")) {  // scattered logic\n      emp = new IOSDeveloper();\n    }\n    \n    System.out.println(emp.name() + \" hired with salary: $\" + emp.getSalary());\n  }\n}\n\npublic class PayrollService {\n  public void calculatePayroll(String type) {\n    Employee emp;\n    \n    if (type.equals(\"WEB\")) {  // REPEATED logic!\n      emp = new WebDeveloper();\n    } else if (type.equals(\"ANDROID\")) {  // REPEATED logic!\n      emp = new AndroidDeveloper();\n    } else if (type.equals(\"IOS\")) {  // REPEATED logic!\n      emp = new IOSDeveloper();\n    }\n    \n    System.out.println(\"Payroll for \" + emp.name() + \": $\" + emp.getSalary());\n  }\n}\n\npublic class ReportService {\n  public void generateReport(String type) {\n    Employee emp;\n    \n    if (type.equals(\"WEB\")) {  // REPEATED again!\n      emp = new WebDeveloper();\n    } else if (type.equals(\"ANDROID\")) {  // REPEATED again!\n      emp = new AndroidDeveloper();\n    }\n    \n    System.out.println(\"Report: \" + emp.name());\n  }\n}\n```\n\n**Problems:**\n1. **Code duplication** - Same if/else logic in 3 different classes\n2. **Hard to maintain** - Adding IOSDeveloper means changing 3 classes\n3. **Hard to test** - Can't test without creating real objects\n4. **Tight coupling** - All classes depend on concrete Employee classes\n5. **Hard to extend** - Each new type requires finding all places with the if/else\n\n**WITH Abstract Factory - GOOD!**\n```java\n// EmployeeFactory encapsulates all creation logic\npublic class EmployeeFactory {\n  public static Employee getEmployee(EmployeeAbstractFactory factory) {\n    return factory.createEmployee();\n  }\n}\n\n// Now all services use the factory - NO duplication!\npublic class EmployeeService {\n  public void hireEmployee(EmployeeAbstractFactory factory) {\n    Employee emp = EmployeeFactory.getEmployee(factory);  // clean!\n    System.out.println(emp.name() + \" hired with salary: $\" + emp.getSalary());\n  }\n}\n\npublic class PayrollService {\n  public void calculatePayroll(EmployeeAbstractFactory factory) {\n    Employee emp = EmployeeFactory.getEmployee(factory);  // reusable!\n    System.out.println(\"Payroll for \" + emp.name() + \": $\" + emp.getSalary());\n  }\n}\n\npublic class ReportService {\n  public void generateReport(EmployeeAbstractFactory factory) {\n    Employee emp = EmployeeFactory.getEmployee(factory);  // consistent!\n    System.out.println(\"Report: \" + emp.name());\n  }\n}\n\n// Usage - all services work the same way\npublic class Client {\n  public static void main(String args[]) {\n    EmployeeAbstractFactory webFactory = new WebDeveloperFactory();\n    EmployeeAbstractFactory androidFactory = new AndroidDeveloperFactory();\n    \n    EmployeeService empService = new EmployeeService();\n    PayrollService payroll = new PayrollService();\n    ReportService report = new ReportService();\n    \n    // All services work with ANY factory - no coupling!\n    empService.hireEmployee(webFactory);      // Works!\n    payroll.calculatePayroll(androidFactory); // Works!\n    report.generateReport(webFactory);        // Works!\n  }\n}\n\n// Output:\n// Web Developer hired with salary: $12000\n// Payroll for Android Developer: $15000\n// Report: Web Developer\n```\n\n**Benefits:**\n1. **No code duplication** - Creation logic in ONE place (EmployeeFactory)\n2. **Easy to maintain** - Adding IOSDeveloper requires NO changes to services\n3. **Easy to test** - Pass mock factory to test\n4. **Loose coupling** - Services depend only on EmployeeAbstractFactory interface\n5. **Easy to extend** - New developer types automatically work with all services\n\n**Key Insight:** Abstract Factory centralizes creation logic and makes all client code independent of concrete types!\n\n---\n\n### Q5: How do you ensure product families are consistent?\n\n**Answer:**\nThe Abstract Factory pattern itself enforces consistency by design:\n\n1. **Type system enforces it:**\n```java\n// Each factory creates one type of employee\npublic class WebDeveloperFactory extends EmployeeAbstractFactory {\n  @Override\n  public Employee createEmployee() {\n    return new WebDeveloper();  // ALWAYS WebDeveloper!\n  }\n}\n\npublic class AndroidDeveloperFactory extends EmployeeAbstractFactory {\n  @Override\n  public Employee createEmployee() {\n    return new AndroidDeveloper();  // ALWAYS AndroidDeveloper!\n  }\n}\n\n// Impossible to mix - type system prevents it!\nEmployeeAbstractFactory factory = new WebDeveloperFactory();\nEmployee emp = factory.createEmployee();  // Always WebDeveloper\n```\n\n2. **Real-world example with multiple products per family:**\n```java\n// If you had multiple products per factory (UI example):\npublic interface UIFactory {\n  Button createButton();\n  Checkbox createCheckbox();\n}\n\npublic class WindowsUIFactory implements UIFactory {\n  @Override\n  public Button createButton() { \n    return new WindowsButton();      // Windows button\n  }\n  @Override\n  public Checkbox createCheckbox() { \n    return new WindowsCheckbox();    // Windows checkbox (guaranteed match!)\n  }\n}\n\n// IMPOSSIBLE to get mismatched products!\nUIFactory factory = new WindowsUIFactory();\nButton btn = factory.createButton();        // Windows\nCheckbox cb = factory.createCheckbox();     // Windows (100% consistent!)\n\n// You CANNOT do this:\n// Button btn = new WindowsButton();       // Windows\n// Checkbox cb = new MacCheckbox();        // Mac (ERROR - can't happen!)\n```\n\n3. **Validation for extra safety:**\n```java\n// Optional: add validation to ensure consistency\npublic class EmployeeValidator {\n  public static void validateConsistency(List<Employee> employees) {\n    if (employees.isEmpty()) return;\n    \n    String firstType = employees.get(0).getClass().getSimpleName();\n    \n    for (Employee emp : employees) {\n      String empType = emp.getClass().getSimpleName();\n      if (!empType.startsWith(firstType.split(\"Developer\")[0])) {\n        throw new IllegalStateException(\n          \"Inconsistent employee types: expected \" + firstType + \n          \" but got \" + empType\n        );\n      }\n    }\n  }\n}\n\n// Usage\npublic class Client {\n  public static void main(String args[]) {\n    List<Employee> employees = new ArrayList<>();\n    \n    employees.add(EmployeeFactory.getEmployee(new WebDeveloperFactory()));\n    employees.add(EmployeeFactory.getEmployee(new WebDeveloperFactory()));\n    employees.add(EmployeeFactory.getEmployee(new WebDeveloperFactory()));\n    \n    // Validate all are consistent\n    EmployeeValidator.validateConsistency(employees);\n    System.out.println(\"All employees are consistent!\");\n  }\n}\n```\n\n**Key Takeaway:** The pattern's structure naturally ensures consistency - each factory is responsible for one family, and you can't accidentally mix products from different families because each factory method has one specific implementation.\n\n---\n\n### Q6: How to avoid switch/if-else in factories?\n\n**Answer:**\nThere are several approaches to eliminate if-else chains in factories:\n\n**Approach 1: Map-based Registry (Recommended)**\n```java\npublic class RegistryEmployeeFactory {\n  private static Map<String, EmployeeAbstractFactory> registry = new HashMap<>();\n  \n  static {\n    registry.put(\"web\", new WebDeveloperFactory());\n    registry.put(\"android\", new AndroidDeveloperFactory());\n    registry.put(\"ios\", new IOSDeveloperFactory());\n  }\n  \n  public Employee getEmployee(String type) {\n    EmployeeAbstractFactory factory = registry.get(type.toLowerCase());\n    if (factory == null) {\n      throw new IllegalArgumentException(\"Unknown employee type: \" + type);\n    }\n    return EmployeeFactory.getEmployee(factory);\n  }\n  \n  // Easy to extend - no code modification needed!\n  public static void registerFactory(String name, EmployeeAbstractFactory factory) {\n    registry.put(name, factory);\n  }\n}\n\n// Usage:\nRegistryEmployeeFactory factory = new RegistryEmployeeFactory();\nEmployee emp = factory.getEmployee(\"web\");  // No if-else!\n\n// Later, add new developer type without modifying factory:\nRegistryEmployeeFactory.registerFactory(\"devops\", new DevOpsFactory());\n```\n\n**Approach 2: Enum-based Factory**\n```java\npublic enum DeveloperType {\n  WEB(WebDeveloperFactory::new),\n  ANDROID(AndroidDeveloperFactory::new),\n  IOS(IOSDeveloperFactory::new);\n  \n  private final Supplier<EmployeeAbstractFactory> supplier;\n  \n  DeveloperType(Supplier<EmployeeAbstractFactory> supplier) {\n    this.supplier = supplier;\n  }\n  \n  public Employee create() {\n    return EmployeeFactory.getEmployee(supplier.get());\n  }\n}\n\n// Usage:\nEmployee emp = DeveloperType.WEB.create();  // Type-safe!\n```\n\n**Approach 3: Strategy Pattern with Factory**\n```java\npublic class StrategyEmployeeFactory {\n  private Map<String, Supplier<EmployeeAbstractFactory>> strategies = new HashMap<>();\n  \n  public StrategyEmployeeFactory() {\n    strategies.put(\"web\", WebDeveloperFactory::new);\n    strategies.put(\"android\", AndroidDeveloperFactory::new);\n    strategies.put(\"ios\", IOSDeveloperFactory::new);\n  }\n  \n  public Employee getEmployee(String type) {\n    Supplier<EmployeeAbstractFactory> supplier = strategies.get(type.toLowerCase());\n    if (supplier == null) throw new IllegalArgumentException(\"Unknown type\");\n    return EmployeeFactory.getEmployee(supplier.get());\n  }\n}\n```\n\n**Comparison:**\n\n| Approach | Pros | Cons |\n|----------|------|------|\n| Map Registry | Simple, extensible | Reflection overhead |\n| Enum | Type-safe, no strings | Fixed at compile time |\n| Strategy | Flexible, testable | More objects |\n\n**Best Practice:** Use **Map-based Registry** for most cases!\n\n---\n\n### Q7: When choose Factory vs Builder?\n\n**Answer:**\nFactory and Builder solve different problems. Choose based on your needs:\n\n**Use Factory Pattern when:**\n- Creating **simple objects** with few variations\n- Need to **hide concrete class** details from client\n- Creating objects **based on a type/condition**\n- Object creation is **straightforward**\n\n```java\n// Factory makes sense here - simple creation of employee types\nEmployee emp = factory.getEmployee(new WebDeveloperFactory());\n```\n\n**Use Builder Pattern when:**\n- Creating **complex objects** with many properties\n- Object has **many optional parameters**\n- Need to create **different representations** of same object\n- Want to avoid **telescoping constructors**\n- Need **immutable objects** with validation\n\n```java\n// Builder makes sense here - complex object\nStudent student = new StudentBuilder()\n  .setRollNo(101)\n  .setName(\"John\")\n  .setCourseName(\"B.Tech\")\n  .setAge(20)\n  .setFatherName(\"Ram\")\n  .setEmailId(\"john@example.com\")\n  .build();\n```\n\n**Side-by-Side Comparison:**\n\n| Aspect | Factory | Builder |\n|--------|---------|---------|\n| **Object Complexity** | Simple | Complex (many properties) |\n| **Number of Parameters** | Few | Many (with optionals) |\n| **Constructor Overloads** | 1-2 | Avoided (problem factory solves) |\n| **Validation** | Optional | At build() time |\n| **Immutability** | Not guaranteed | Can be guaranteed |\n| **Creation Process** | One-shot | Step-by-step |\n| **Family of Objects** | Different types | Different representations |\n\n**Real-world Example:**\n\n```java\n// FACTORY: Simple type selection for employee families\npublic class EmployeeFactory {\n  public Employee getEmployee(EmployeeAbstractFactory factory) {\n    return factory.createEmployee();\n  }\n}\n\n// BUILDER: Complex object construction for configurations\npublic class DatabaseConfigBuilder {\n  private String host = \"localhost\";\n  private int port = 3306;\n  private String username = \"root\";\n  private String password = \"\";\n  private int poolSize = 10;\n  private boolean ssl = false;\n  \n  public DatabaseConfigBuilder host(String host) {\n    this.host = host;\n    return this;\n  }\n  \n  public DatabaseConfigBuilder port(int port) {\n    this.port = port;\n    return this;\n  }\n  \n  public DatabaseConfig build() {\n    validate();  // Ensure required fields are set\n    return new DatabaseConfig(host, port, username, password, poolSize, ssl);\n  }\n}\n\n// Usage:\n// Factory for creating employee families\nEmployee webDev = new EmployeeFactory().getEmployee(new WebDeveloperFactory());\n\n// Builder for complex configuration\nDatabaseConfig config = new DatabaseConfigBuilder()\n  .host(\"db.example.com\")\n  .port(5432)\n  .username(\"admin\")\n  .password(\"secret\")\n  .build();\n```\n\n**Decision Tree:**\n\n```\nDo you need to create ONE of many different FAMILIES?\n  \u251c\u2500 YES \u2192 Use ABSTRACT FACTORY (Windows vs Mac UI family)\n  \u2514\u2500 NO \u2192 Next question\n\nDo you have many optional properties to set?\n  \u251c\u2500 YES \u2192 Use BUILDER (Student: name, age, email, phone, etc.)\n  \u2514\u2500 NO \u2192 Direct constructor or simple factory\n```\n\n**Key Insight:**\n- **Factory** = \"What family of objects should I create?\"\n- **Builder** = \"How should I construct this complex object step-by-step?\"\n\nYou can even combine both:\n```java\n// Factory creates Employee via consistent configuration\npublic class EmployeeHiringService {\n  public Employee hireDeveloper(String type, String name, int salary) {\n    EmployeeAbstractFactory factory = getFactory(type);\n    Employee emp = factory.createEmployee();\n    // Could use builder for complex employee setup\n    return emp;\n  }\n}\n```\n"</script>
  <script src="tools/pattern_renderer.js"></script>
</body>
</html>