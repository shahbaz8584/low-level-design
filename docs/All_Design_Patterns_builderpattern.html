<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Builder Pattern - Design Patterns</title>
  <link rel="stylesheet" href="tools/index_style.css">
  <link rel="stylesheet" href="tools/patterns_responsive.css">
  <link rel="stylesheet" href="tools/pattern_page.css">
  <link rel="stylesheet" href="tools/pattern_layout.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
</head>
<body style="background: #f7fafc;">
  <div style="max-width: 1200px; margin: 0 auto; padding: 1.5rem;">
    <a href="All_Design_Patterns_Creational.html" class="back-button">‚Üê Back to Patterns</a>
    
    <div class="pattern-header">
      <div class="breadcrumb">Design Patterns</div>
      <h1>Builder Pattern</h1>
    </div>

    <div class="pattern-container">
      <aside class="pattern-toc">
        <h4>Contents</h4>
        <ul id="toc-list"></ul>
      </aside>
      <div class="pattern-main">
        <div class="uml-section">
    <h2>Class Diagram</h2>
    <div class="mermaid">classDiagram
    class Student {
        -name: String
        -age: int
        -branch: String
        -courses: List
        -Student(builder)
    }

    class StudentBuilder {
        -name: String
        -age: int
        -branch: String
        -courses: List
        +setName(String): StudentBuilder
        +setAge(int): StudentBuilder
        +setBranch(String): StudentBuilder
        +addCourse(String): StudentBuilder
        +build(): Student
    }

    Student --> StudentBuilder: created by</div>
    <div class="uml-caption">UML Class Diagram for Builder Pattern</div>
  </div>
  
        <article id="content" class="markdown-body"></article>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script id="md-data" type="application/json">"# Builder Pattern \u2014 Interview Reference\n\n## Intent\nSeparate the construction of a complex object from its representation, allowing the same construction process to create different representations.\n\n## Problem Statement\nObjects with many optional parameters and complex initialization logic become hard to construct. Multiple constructor overloads (telescoping constructor anti-pattern) or setters that leave objects in invalid states lead to error-prone code and maintenance nightmares.\n\n## Why Simple Code Fails\nTelescoping constructors and setter methods create several problems:\n- Too many constructor overloads with different parameter combinations\n- Objects can be left in partially initialized invalid states\n- Hard to distinguish between required and optional parameters\n- Code becomes unreadable with many parameters\n\n## Solution Overview\nIntroduce a Builder class that encapsulates step-by-step construction. The builder provides a fluent interface for setting properties and a final `build()` method that creates the immutable object with validation.\n\n## Participants / Roles\n- Product (complex object being constructed)\n- Builder (specifies steps to construct the product)\n- ConcreteBuilder (implements builder interface)\n- Director (optional - orchestrates builder steps)\n\n## Runtime Execution Flow\n1. Client creates a Builder instance\n2. Client calls builder methods to set properties (fluent interface)\n3. Client calls build() to construct the final Product\n4. Builder validates state and returns immutable Product\n\n## Minimal Java Example\n## Without Pattern\n\n```java\n// Telescoping constructor anti-pattern\npublic class House {\n  public House(String walls) { ... }\n  public House(String walls, String roof) { ... }\n  public House(String walls, String roof, String windows) { ... }\n  public House(String walls, String roof, String windows, String doors) { ... }\n  // 20+ more overloads...\n}\n\n// Usage is confusing\nHouse h = new House(\"brick\", \"tiles\", \"glass\", \"wood\");\n```\n\n## With Pattern\n\n```java\n// Builder pattern with fluent interface\npublic class House {\n  private String walls;\n  private String roof;\n  private String windows;\n  private String doors;\n  \n  private House(Builder builder) {\n    this.walls = builder.walls;\n    this.roof = builder.roof;\n    this.windows = builder.windows;\n    this.doors = builder.doors;\n  }\n  \n  public static class Builder {\n    private String walls = \"brick\";\n    private String roof = \"tiles\";\n    private String windows = \"glass\";\n    private String doors = \"wood\";\n    \n    public Builder walls(String walls) { \n      this.walls = walls; \n      return this; \n    }\n    public Builder roof(String roof) { \n      this.roof = roof; \n      return this; \n    }\n    public Builder windows(String windows) { \n      this.windows = windows; \n      return this; \n    }\n    public Builder doors(String doors) { \n      this.doors = doors; \n      return this; \n    }\n    \n    public House build() {\n      return new House(this);\n    }\n  }\n}\n\n// Usage - clear and readable\nHouse house = new House.Builder()\n  .walls(\"brick\")\n  .roof(\"tiles\")\n  .build();\n```\n\n## Advantages\n- Handles complex objects with many optional parameters cleanly\n- Fluent interface makes code more readable\n- Ensures objects are fully initialized before use\n- Allows immutable objects (thread-safe)\n- Separates construction logic from business logic\n- Easy to add new optional properties without breaking existing code\n- Validation can happen once in build() method\n\n## Disadvantages\n- More code boilerplate (though IDEs help)\n- Overkill for simple objects with few parameters\n- Requires creating a separate builder class\n- Slight performance overhead compared to direct construction\n\n## When NOT to Use\n- Objects with only one or two parameters\n- Objects that don't need validation\n- Simple data transfer objects (DTOs)\n- When immutability isn't important\n\n## Common Mistakes\n- Making the builder mutable (reusable builders)\n- Not providing default values for optional parameters\n- Forgetting validation in build() method\n- Using builder for simple objects (over-engineering)\n- Not making the final product immutable\n\n## Framework / Library Usage\n- **Java**: StringBuilder, Lombok (@Builder), Java 14+ records\n- **Guava**: ImmutableList.Builder, ImmutableMap.Builder\n- **Spring**: ServerRequestBuilder, RestTemplate\n- **SQL**: PreparedStatement uses builder pattern\n- **Protocol Buffers**: Auto-generated builders for message types\n\n## System Design Use Cases\n- Configuration objects with many optional settings\n- HTTP requests (URL, headers, body, cookies)\n- Database connection strings and pool configuration\n- JSON/XML document construction\n- UI component creation (Android, Swing)\n- SQL query builders\n\n## Interview One-Liner\nBuilder pattern provides a fluent, step-by-step interface for constructing complex objects while maintaining immutability and ensuring valid state.\n\n## Common Interview Questions\n\n### Q1: What problem does Builder solve that constructor overloads don't?\n\n**Answer:** The telescoping constructor anti-pattern requires many overloaded constructors for different parameter combinations:\n- Constructor explosion: With 10 optional parameters, you need 2^10 = 1024 overloads\n- Order matters: Easy to pass parameters in wrong order (all Strings confuse positions)\n- Invalid states: Setters can leave objects partially initialized\n\nBuilder solves this by:\n- Single builder class with fluent methods (setX().setY().setZ())\n- Clear parameter names make code self-documenting\n- Validation happens only in build() - prevents invalid states\n- Immutable final object once built\n\n**Code Example:**\n```java\n// Without Builder (hard to read, many overloads)\nHouse h = new House(\"brick\", \"tiles\", \"glass\", \"wood\", true, false);\n\n// With Builder (clear intent)\nHouse h = new HouseBuilder()\n    .withWalls(\"brick\")\n    .withRoof(\"tiles\")\n    .withWindows(\"glass\")\n    .withDoors(\"wood\")\n    .hasGarden(true)\n    .build();\n```\n\n### Q2: How does Builder relate to immutability?\n\n**Answer:** Builder enables immutability by:\n1. Separating construction (mutable builder) from usage (immutable object)\n2. Final object is created all at once in build() - no setters after creation\n3. Builder handles complex initialization - final object just stores values\n4. Thread-safe: Immutable objects can be shared safely\n\n**Code Example:**\n```java\npublic class Student {\n    private final String name;\n    private final int age;\n    private final List<String> courses;\n    \n    private Student(StudentBuilder builder) {\n        this.name = builder.name;\n        this.age = builder.age;\n        this.courses = Collections.unmodifiableList(builder.courses);\n    }\n    \n    public static class StudentBuilder {\n        // ... fluent methods return 'this' ...\n        \n        public Student build() {\n            return new Student(this); // Create immutable instance\n        }\n    }\n}\n```\n\n### Q3: What problems arise without Builder Pattern?\n\n**Answer:** Without Builder:\n- **Consistency issues**: Objects can be left in incomplete states with missing required fields\n- **Constructor hell**: Adding optional parameters requires recompiling and updating all constructors\n- **Hard to maintain**: Changes to object structure break many constructor signatures\n- **Readability**: `new House(\"brick\", \"tiles\", null, null, true)` - unclear what parameters mean\n- **Thread-safety**: Setters after construction can cause race conditions\n- **Validation burden**: Must validate in every constructor overload\n\n### Q4: How is Builder different from Factory?\n\n**Answer:** \n| Aspect | Builder | Factory |\n|--------|---------|---------|\n| **Purpose** | Construct complex objects step-by-step | Create objects (right type) |\n| **Complexity** | For objects with many optional parameters | For choosing which concrete type to create |\n| **Control** | User controls each step | Factory hides creation logic |\n| **Immutability** | Final object is immutable | Creates mutable objects |\n| **Use Case** | Complex object with options (House, SQL Query) | Choosing implementation (ShapeFactory) |\n\n**Example:**\n```java\n// Factory - decides WHICH object type\nShape s = ShapeFactory.getShape(\"circle\"); // Circle or Rectangle?\n\n// Builder - HOW to construct complex object\nHouse h = new HouseBuilder()\n    .withWalls(\"brick\")\n    .withRoof(\"tiles\")\n    .build();\n```\n\n### Q5: Can you make a reusable builder? Should you?\n\n**Answer:** Yes, reusable builders can be designed:\n\n```java\n// Reusable builder for multiple objects\npublic class GenericBuilder<T> {\n    private final Supplier<T> supplier;\n    private final List<Consumer<T>> functions = new ArrayList<>();\n    \n    public GenericBuilder(Supplier<T> supplier) {\n        this.supplier = supplier;\n    }\n    \n    public <V> GenericBuilder<T> with(BiConsumer<T, V> setter, V value) {\n        functions.add(obj -> setter.accept(obj, value));\n        return this;\n    }\n    \n    public T build() {\n        T obj = supplier.get();\n        functions.forEach(f -> f.accept(obj));\n        return obj;\n    }\n}\n\n// Usage\nPerson p = new GenericBuilder<>(Person::new)\n    .with(Person::setName, \"John\")\n    .with(Person::setAge, 30)\n    .build();\n```\n\n**Should you?** It depends:\n- \u2713 For simple objects with setters\n- \u2717 For complex objects needing validation (use specific builders)\n- \u2717 If you need immutability (generic builder requires setters)\n- Use Lombok `@Builder` annotation in practice instead\n\n### Q6: What's the performance impact of using Builder?\n\n**Answer:** \n- **Memory**: +1 temporary builder object (negligible for most cases)\n- **Speed**: Extra method calls during building (negligible - compiler inlines)\n- **GC**: Builder object collected after build() (no issue)\n\n**When it matters:**\n- Not a performance bottleneck in most applications\n- Creating millions of objects in tight loops could show difference (rare)\n- Trade-off for code clarity is usually worth it\n\n**Example:**\n```java\n// Same performance (compiler optimizes)\nHouse h = new HouseBuilder().withWalls(\"brick\").build();\nHouse h2 = new House(\"brick\"); // Not much difference in bytecode\n```\n\n### Q7: How would you combine Builder with other patterns?\n\n**Answer:**\n```java\n// Builder + Composite (building trees)\nTreeNode root = new NodeBuilder()\n    .addChild(new NodeBuilder().withValue(1).build())\n    .addChild(new NodeBuilder().withValue(2).build())\n    .build();\n\n// Builder + Strategy (configuring strategy at build time)\nRequest req = new RequestBuilder()\n    .withRetryStrategy(new ExponentialBackoffStrategy())\n    .withTimeout(5000)\n    .build();\n\n// Builder + Template Method (builder with hooks)\npublic abstract class SpecializedBuilder<T> {\n    protected T build() {\n        validateFields();      // Template method hook\n        T obj = construct();\n        postConstruct(obj);    // Another hook\n        return obj;\n    }\n}\n```\n\n"</script>
  <script src="tools/pattern_renderer.js"></script>
</body>
</html>