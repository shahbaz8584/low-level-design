<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Singleton Pattern - Design Patterns</title>
  <link rel="stylesheet" href="tools/index_style.css">
  <link rel="stylesheet" href="tools/patterns_responsive.css">
  <link rel="stylesheet" href="tools/pattern_page.css">
  <link rel="stylesheet" href="tools/pattern_layout.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
</head>
<body style="background: #f7fafc;">
  <div style="max-width: 1200px; margin: 0 auto; padding: 1.5rem;">
    <a href="All_Design_Patterns_index.html" class="back-button">‚Üê Back to Patterns</a>
    
    <div class="pattern-header">
      <div class="breadcrumb">Design Patterns</div>
      <h1>Singleton Pattern</h1>
    </div>

    <div class="pattern-container">
      <aside class="pattern-toc">
        <h4>Contents</h4>
        <ul id="toc-list"></ul>
      </aside>
      <div class="pattern-main">
        <div class="uml-section">
    <h2>Class Diagram</h2>
    <div class="mermaid">classDiagram
    class DBConnection {
        -instance: DBConnection static
        -connection: Connection private
        -DBConnection() private
        +getInstance()‚ú® DBConnection static
        +executeQuery(String) void
        +closeConnection() void
    }
    
    note for DBConnection "‚ú® Only ONE instance exists\nüîí Private constructor\nüåç Global access point"</div>
  </div>
  
        <article id="content" class="markdown-body"></article>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script id="md-data" type="application/json">"# Singleton Pattern \u2014 Interview Reference\n\n## Intent\nEnsure a class has only one instance and provide a global access point.\n\n## Problem Statement\nMultiple parts of a system require a single shared resource/configuration; naive globals lead to uncontrolled instantiation and state issues.\n\n## Why Simple Code Fails\nUsing public static fields or unguarded lazy init leads to thread-safety bugs and testing difficulties.\n\n## Solution Overview\nExpose a single instance through a controlled access method; handle lazy initialization safely and consider dependency injection alternatives.\n\n## Participants / Roles\n- Singleton (the single instance holder)\n\n## Runtime Execution Flow\n1. Client requests Singleton.getInstance()\n2. getInstance() either returns existing instance or initializes it safely\n3. Client uses shared instance\n\n## Minimal Java Example\n## Without Pattern\n\n```java\n// Without Singleton: using public static field or multiple instances\nConfig a = new Config();\nConfig b = new Config();\n```\n\n## With Pattern\n\n```java\n// With Singleton: single shared instance\nConfig cfg = Config.getInstance();\n```\n\n\n```java\npublic class Config {\n  private static volatile Config instance;\n  private Config(){}\n  public static Config getInstance(){\n    if(instance==null){\n      synchronized(Config.class){\n        if(instance==null) instance = new Config();\n      }\n    }\n    return instance;\n  }\n}\n```\n\n## Advantages\n- Controlled access to single instance\n- Useful for shared resources\n\n## Disadvantages\n- Global state hampers testability\n- Can hide dependencies and increase coupling\n\n## When NOT to Use\n- When DI can provide better lifecycle and scoping\n- For per-request or short-lived objects\n\n## Common Mistakes\n- Not handling thread-safety\n- Using Singleton as a catch-all global\n\n## Framework / Library Usage\n- Use dependency injection (Spring beans with singleton scope) rather than hand-rolled singletons where possible.\n\n## System Design Use Cases\n- Configuration managers, caches, connection pools (careful: pools are better as separate objects), logging facades\n\n## Interview One-Liner\nSingleton ensures a single instance and global access, but can introduce global state and testability problems.\n\n## Common Interview Questions\n\n### Q1: How to write thread-safe lazy singleton in Java?\n\n**Answer:** There are multiple approaches with different trade-offs:\n\n**1. Double-Checked Locking (Most Common):**\n```java\npublic class DBConnection {\n    private static volatile DBConnection instance;\n    \n    private DBConnection() { }\n    \n    public static DBConnection getInstance() {\n        if (instance == null) {\n            synchronized(DBConnection.class) {\n                if (instance == null) {\n                    instance = new DBConnection();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n**2. Bill Pugh Singleton (Best - Uses Class Loader):**\n```java\npublic class DBConnection {\n    private DBConnection() { }\n    \n    private static class SingletonHelper {\n        private static final DBConnection INSTANCE = new DBConnection();\n    }\n    \n    public static DBConnection getInstance() {\n        return SingletonHelper.INSTANCE;\n    }\n}\n```\n\n**3. Enum Singleton (Most Bulletproof):**\n```java\npublic enum DBConnection {\n    INSTANCE;\n    \n    public void query(String sql) {\n        // Implementation\n    }\n}\n\n// Usage\nDBConnection.INSTANCE.query(\"SELECT *\");\n```\n\n### Q2: Why is 'volatile' required in double-checked locking?\n\n**Answer:** Without `volatile`, the second check `instance == null` might see partially initialized object due to reordering:\n\n```java\n// BAD - without volatile\nprivate static DBConnection instance;\n\npublic static DBConnection getInstance() {\n    if (instance == null) {  // Thread A sees partially initialized object!\n        synchronized(DBConnection.class) {\n            if (instance == null) {\n                instance = new DBConnection(); // Not fully constructed yet\n            }\n        }\n    }\n    return instance;\n}\n\n// GOOD - with volatile ensures visibility\nprivate static volatile DBConnection instance;\n\n// volatile forces:\n// 1. Memory barrier - all writes visible to all threads\n// 2. Prevent instruction reordering\n```\n\n### Q3: When are singletons harmful?\n\n**Answer:** Singletons create problems despite simplicity:\n\n- **Global state**: Hidden dependency - hard to track who modifies it\n- **Testing nightmare**: Can't mock singletons, state carries between tests\n- **Thread-safety**: Complex synchronized code hard to maintain\n- **Cannot subclass**: Final to prevent multiple instances\n- **Lifetime control**: Can't control creation/destruction\n- **Hidden coupling**: Classes implicitly depend on global singleton\n\n**Example of problems:**\n```java\n// Hard to test - can't replace with mock\nDatabaseConnection.getInstance().query(...);\n\n// State pollution between tests\n@Test void test1() {\n    cache.put(\"key\", \"value\");\n}\n\n@Test void test2() {\n    assertEquals(\"value\", cache.get(\"key\")); // Fails if test1 ran first!\n}\n```\n\n### Q4: What are alternatives to Singleton?\n\n**Answer:**\n```java\n// 1. Dependency Injection (PREFERRED)\npublic class Service {\n    private DatabaseConnection db;\n    \n    public Service(DatabaseConnection db) { // Inject dependency\n        this.db = db;\n    }\n}\n\n// 2. Static Factory Method\npublic class Config {\n    public static Config getInstance() {\n        return new Config(); // Appears like singleton but testable\n    }\n}\n\n// 3. Service Locator (Anti-pattern but alternative)\nServiceLocator.register(\"db\", new DatabaseConnection());\nDatabaseConnection db = ServiceLocator.get(\"db\");\n\n// 4. ThreadLocal (For thread-scoped singletons)\npublic class RequestContext {\n    private static ThreadLocal<RequestContext> context = new ThreadLocal<>();\n    \n    public static RequestContext getInstance() {\n        RequestContext ctx = context.get();\n        if (ctx == null) {\n            ctx = new RequestContext();\n            context.set(ctx);\n        }\n        return ctx;\n    }\n}\n```\n\n### Q5: How is eager initialization different from lazy initialization?\n\n**Answer:**\n| Aspect | Eager | Lazy |\n|--------|-------|------|\n| **When created** | JVM startup (class loading) | First call to getInstance() |\n| **Thread-safe** | Always (class loader handles) | Must synchronize |\n| **Startup time** | Slower (create all singletons upfront) | Faster (create on demand) |\n| **Memory** | Uses memory immediately | Uses memory only when needed |\n| **Exceptions** | Throw during startup (fail-fast) | Throw at first access (bad) |\n\n**Code:**\n```java\n// Eager - created when class loads\npublic class Config {\n    private static final Config INSTANCE = new Config();\n    \n    public static Config getInstance() {\n        return INSTANCE;\n    }\n}\n\n// Lazy - created first time getInstance() called\npublic class Config {\n    private static Config instance;\n    \n    public static synchronized Config getInstance() {\n        if (instance == null) {\n            instance = new Config();\n        }\n        return instance;\n    }\n}\n```\n\n### Q6: How does Singleton behave with reflection/serialization?\n\n**Answer:** Reflection and serialization can break singleton:\n\n```java\n// PROBLEM 1: Reflection creates new instance\nDBConnection original = DBConnection.getInstance();\nConstructor<?> constructor = DBConnection.class.getDeclaredConstructor();\nconstructor.setAccessible(true);\nDBConnection fake = (DBConnection) constructor.newInstance(); // NEW INSTANCE!\n\n// Solution: Throw exception in constructor\nprivate DBConnection() {\n    if (instance != null) {\n        throw new IllegalStateException(\"Singleton already exists\");\n    }\n}\n\n// PROBLEM 2: Serialization creates new instance on deserialization\nObjectInputStream in = new ObjectInputStream(file);\nDBConnection deserialized = (DBConnection) in.readObject(); // NEW INSTANCE!\n\n// Solution: Override readResolve()\npublic Object readResolve() {\n    return getInstance(); // Return existing instance\n}\n\n// Solution: Use Enum (handles both automatically)\npublic enum DBConnection {\n    INSTANCE;\n}\n```\n\n### Q7: Should you use Singleton in microservices?\n\n**Answer:** Generally NO - different context:\n\n```java\n// Monolith - ONE JVM = ONE instance\nConfig cfg = Config.getInstance(); // Makes sense\n\n// Microservices - MULTIPLE instances per service (horizontal scaling)\n// Replica 1: has Config.INSTANCE\n// Replica 2: has different Config.INSTANCE (different memory!)\n// Not truly \"single\"\n\n// Better approaches for microservices:\n// 1. Dependency Injection with container lifecycle\n@Bean(scope = \"singleton\")\npublic Config config() {\n    return new Config();\n}\n\n// 2. Configuration Server (shared config for all instances)\nConfiguration config = configServer.getConfig(\"database\");\n\n// 3. Distributed Cache (Redis, Memcached)\nCache cache = distributedCache.get(\"singleton-key\");\n```\n"</script>
  <script src="tools/pattern_renderer.js"></script>
</body>
</html>